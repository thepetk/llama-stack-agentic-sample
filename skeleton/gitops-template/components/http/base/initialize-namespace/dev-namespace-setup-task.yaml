# Self-contained namespace setup Task
# This Task creates all required secrets for the AI Software Template to function
# No external dependency required - the script is embedded directly
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: ${{ values.name }}-dev-namespace-setup
  labels:
    app.kubernetes.io/instance: ${{ values.name }}
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/name: ${{ values.name }}-dev-namespace-setup
    app.kubernetes.io/part-of: ${{ values.name }}
    app.kubernetes.io/component: namespace-setup
spec:
  description: |-
    Create the required resources for AI Software Template tasks to run in a namespace.
    This includes secrets for Git authentication, image registry, webhooks, and signing.
    Reads credentials from the platform-credentials secret in the same namespace.
  params:
    - name: platform_secret_name
      type: string
      default: 'platform-credentials'
      description: |
        Name of the Kubernetes Secret containing platform credentials
        (GITHUB_TOKEN, GITLAB_TOKEN, WEBHOOK_SECRET, QUAY_DOCKERCONFIGJSON)
    # Note: cosign_public_key is auto-fetched from openshift-pipelines namespace
  steps:
    - name: setup-namespace
      image: "registry.redhat.io/openshift4/ose-tools-rhel9:v4.18"
      env:
        - name: PLATFORM_SECRET_NAME
          value: $(params.platform_secret_name)
      script: |
        #!/usr/bin/env bash
        set -o errexit
        set -o nounset
        set -o pipefail

        echo "=== Initializing namespace with required secrets ==="

        # Read credentials from the platform-credentials secret
        echo "* Reading credentials from $PLATFORM_SECRET_NAME secret..."
        GITHUB_TOKEN=$(kubectl get secret "$PLATFORM_SECRET_NAME" -o jsonpath='{.data.GITHUB_TOKEN}' 2>/dev/null | base64 -d 2>/dev/null) || GITHUB_TOKEN=""
        GITLAB_TOKEN=$(kubectl get secret "$PLATFORM_SECRET_NAME" -o jsonpath='{.data.GITLAB_TOKEN}' 2>/dev/null | base64 -d 2>/dev/null) || GITLAB_TOKEN=""
        WEBHOOK_SECRET=$(kubectl get secret "$PLATFORM_SECRET_NAME" -o jsonpath='{.data.WEBHOOK_SECRET}' 2>/dev/null | base64 -d 2>/dev/null) || WEBHOOK_SECRET=""
        QUAY_DOCKERCONFIGJSON=$(kubectl get secret "$PLATFORM_SECRET_NAME" -o jsonpath='{.data.QUAY_DOCKERCONFIGJSON}' 2>/dev/null | base64 -d 2>/dev/null) || QUAY_DOCKERCONFIGJSON=""

        # Auto-fetch cosign public key from openshift-pipelines namespace
        SECRET_NAME="cosign-pub"
        echo -n "* Fetching cosign public key from openshift-pipelines: "
        COSIGN_PUBLIC_KEY=""
        RETRY_COUNT=0
        MAX_RETRIES=15
        while [ -z "${COSIGN_PUBLIC_KEY:-}" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo -n "."
          sleep 2
          COSIGN_PUBLIC_KEY=$(kubectl get secrets -n openshift-pipelines signing-secrets -o jsonpath='{.data.cosign\.pub}' 2>/dev/null) || true
          RETRY_COUNT=$((RETRY_COUNT + 1))
        done
        
        if [ -n "$COSIGN_PUBLIC_KEY" ]; then
          echo " Found!"
          echo -n "* Creating $SECRET_NAME secret: "
          cat <<EOF | kubectl apply -f - >/dev/null
        apiVersion: v1
        data:
          cosign.pub: $COSIGN_PUBLIC_KEY
        kind: Secret
        metadata:
          labels:
            app.kubernetes.io/instance: default
            app.kubernetes.io/part-of: tekton-chains
            operator.tekton.dev/operand-name: tektoncd-chains
          name: $SECRET_NAME
        type: Opaque
        EOF
          echo "OK"
        else
          echo " Not found (openshift-pipelines signing-secrets may not be configured)"
          echo "* Skipping $SECRET_NAME secret"
        fi

        # Create gitlab-auth-secret for GitLab authentication
        SECRET_NAME="gitlab-auth-secret"
        if kubectl get secret "$SECRET_NAME" >/dev/null 2>&1; then
          echo "* $SECRET_NAME secret already exists, skipping"
        elif [ -n "$GITLAB_TOKEN" ]; then
          echo -n "* Creating $SECRET_NAME secret: "
          kubectl create secret generic "$SECRET_NAME" \
            --from-literal=password=$GITLAB_TOKEN \
            --from-literal=username=oauth2 \
            --type=kubernetes.io/basic-auth \
            --dry-run=client -o yaml | kubectl apply --filename - >/dev/null
          echo "OK"
        else
          echo "* Skipping $SECRET_NAME secret (no value provided)"
        fi

        # Create gitops-auth-secret for GitHub Git operations
        SECRET_NAME="gitops-auth-secret"
        if kubectl get secret "$SECRET_NAME" >/dev/null 2>&1; then
          echo "* $SECRET_NAME secret already exists, skipping"
        elif [ -n "$GITHUB_TOKEN" ]; then
          echo -n "* Creating $SECRET_NAME secret: "
          kubectl create secret generic "$SECRET_NAME" \
            --from-literal=password=$GITHUB_TOKEN \
            --type=kubernetes.io/basic-auth \
            --dry-run=client -o yaml | kubectl apply --filename - >/dev/null
          echo "OK"
        else
          echo "* Skipping $SECRET_NAME secret (no value provided)"
        fi

        # Create pipelines-secret for Pipelines as Code webhook
        SECRET_NAME="pipelines-secret"
        if kubectl get secret "$SECRET_NAME" >/dev/null 2>&1; then
          echo "* $SECRET_NAME secret already exists, skipping"
        elif [ -n "$WEBHOOK_SECRET" ]; then
          echo -n "* Creating $SECRET_NAME secret: "
          kubectl create secret generic "$SECRET_NAME" \
            --from-literal=webhook.secret=$WEBHOOK_SECRET \
            --dry-run=client -o yaml | kubectl apply --filename - >/dev/null
          echo "OK"
        else
          echo "* Skipping $SECRET_NAME secret (no value provided)"
        fi

        # Create rhdh-image-registry-token for image registry authentication
        SECRET_NAME="rhdh-image-registry-token"
        if kubectl get secret "$SECRET_NAME" >/dev/null 2>&1; then
          echo "* $SECRET_NAME secret already exists, skipping"
        elif [ -n "$QUAY_DOCKERCONFIGJSON" ]; then
          echo -n "* Creating $SECRET_NAME secret: "
          DATA=$(mktemp)
          echo -n "$QUAY_DOCKERCONFIGJSON" >"$DATA"
          kubectl create secret docker-registry "$SECRET_NAME" \
            --from-file=.dockerconfigjson="$DATA" --dry-run=client -o yaml | \
            kubectl apply --filename - >/dev/null
          rm "$DATA"
          echo -n "."
          
          # Wait for pipeline service account to exist
          echo -n " Waiting for service accounts"
          for i in {1..30}; do
            if kubectl get serviceaccount pipeline >/dev/null 2>&1; then
              break
            fi
            sleep 2
            echo -n "."
          done
          
          # Patch service accounts with image pull secret
          for SA in default pipeline; do
            if kubectl get serviceaccount "$SA" >/dev/null 2>&1; then
              kubectl patch serviceaccounts "$SA" --patch "
        secrets:
          - name: $SECRET_NAME
        imagePullSecrets:
          - name: $SECRET_NAME
        " >/dev/null 2>&1 || true
              echo -n "."
            fi
          done
          echo "OK"
        else
          echo "* Skipping $SECRET_NAME secret (no value provided)"
        fi

        echo "=== Namespace initialization complete ==="

